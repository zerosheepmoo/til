(self.webpackChunktil=self.webpackChunktil||[]).push([[6239],{7951:(e,l,t)=>{"use strict";t.r(l),t.d(l,{default:()=>ee});var i=t(6252);const a=(0,i.Wm)("h1",{id:"test-driven-development"},[(0,i.Wm)("a",{class:"header-anchor",href:"#test-driven-development"},"#"),(0,i.Uk)(" Test Driven Development")],-1),s={href:"https://en.wikipedia.org/wiki/Test-driven_development",target:"_blank",rel:"noopener noreferrer"},r=(0,i.Uk)("tdd wikipedia"),n=(0,i.Wm)("p",null,"작성 중....",-1),o=(0,i.Wm)("h2",{id:"overview"},[(0,i.Wm)("a",{class:"header-anchor",href:"#overview"},"#"),(0,i.Uk)(" Overview")],-1),d=(0,i.Wm)("ul",null,[(0,i.Wm)("li",null,"Software Development Process"),(0,i.Wm)("li",null,"소프트웨어의 개발 전에 테스트 케이스를 만듦"),(0,i.Wm)("li",null,"Kent Beck"),(0,i.Wm)("li",null,"test-first programming concepts of extreme programming 와 관련")],-1),u=(0,i.Wm)("h2",{id:"cycle"},[(0,i.Wm)("a",{class:"header-anchor",href:"#cycle"},"#"),(0,i.Uk)(" Cycle")],-1),h={href:"https://creativecommons.org/licenses/by-sa/4.0/",target:"_blank",rel:"noopener noreferrer"},c=(0,i.Uk)("CC BY-SA 4.0"),p=(0,i.Wm)("img",{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/TDD_Global_Lifecycle.png/2560px-TDD_Global_Lifecycle.png",alt:"Graphical representation"},null,-1),f=(0,i.uE)('<ul><li>아래의 과정은 서적 <em>Test-Driven Development by Example</em> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>을 기반으로 작성되었다.</li></ul><h3 id="_1-테스트-추가-add-a-test"><a class="header-anchor" href="#_1-테스트-추가-add-a-test">#</a> 1. 테스트 추가(Add a test)</h3><ul><li>패스하는 테스트를 작성함으로써 새로운 기능의 추가를 시작한다 <strong>iff</strong> 기능 명세(feature&#39;s spec)에 만족하는 한.</li><li>개발자는 사용 케이스와 사용자 스토리를 묻는 것으로 명세를 찾을 수 있다.</li><li>TDD의 key benefit 은 개발자가 코드를 작성하기 전에 요구사항(requirements)에 집중하게 만드는데에 있다.</li><li>이것은 코드작성 다음에 유닛테스트를 작성한다는 전형적인 관습과는 대비된다.</li></ul><h3 id="_2-모든-테스트-실행-run-all-tests"><a class="header-anchor" href="#_2-모든-테스트-실행-run-all-tests">#</a> 2. 모든 테스트 실행(Run all tests)</h3><ul><li>새로운 테스트는 기대되는 이유(expected reason)에 의하여 실패하여야 한다.</li><li>이는 원하는 기능에 대한 새로운 코드가 필요함을 나타낸다.</li><li>test harness<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 가 잘 작동하는지 검증한다.</li><li>새로운 테스트에 결함이 있는지, 아니면 항상 통과할 것인지에 대한 가능성을 배제한다.</li></ul><h3 id="_3-테스트를-통과하는-가장-간단한-코드-작성-write-the-simplest-code-that-passes-the-new-test"><a class="header-anchor" href="#_3-테스트를-통과하는-가장-간단한-코드-작성-write-the-simplest-code-that-passes-the-new-test">#</a> 3. 테스트를 통과하는 가장 간단한 코드 작성(Write the simplest code that passes the new test)</h3><ul><li>Inelegant or hard code 도 괜찮다.</li><li>코드는 5단계에서 연마될 것이기에</li><li>코드는 테스트된 functionality를 무시하고 추가 될 수는 없다.</li></ul><h3 id="_4-모든-테스트-통과-all-tests-should-now-pass"><a class="header-anchor" href="#_4-모든-테스트-통과-all-tests-should-now-pass">#</a> 4. 모든 테스트 통과(All tests should now pass)</h3><ul><li>만약 실패가 있다면, 새로운 코드는 통과될 때까지 고쳐져야한다.</li><li>이는 새로운 코드가 테스트 요구사항을 충족 시키는 것을 보장한다.</li><li>존재하는 기능들을 망가뜨리지 않는 것도 보장한다.</li></ul><h3 id="_5-리팩토링-refactor-as-needed"><a class="header-anchor" href="#_5-리팩토링-refactor-as-needed">#</a> 5. 리팩토링(Refactor as needed)</h3>',10),m=(0,i.Wm)("li",null,"가독성과 유지보수성을 위해 리팩토리한다.",-1),k=(0,i.Wm)("li",null,"특히 하드코드 된 테스트 데이터는 제거되어야 한다.",-1),v=(0,i.Wm)("li",null,"리팩토링 후 테스트 슈트를 실행하는 것은 어떠한 기능도 망가지지 않았음을 보장한다.",-1),W=(0,i.Uk)("예시 "),g=(0,i.Wm)("li",null,"논리적으로 알맞은 위치에 코드 배치",-1),D=(0,i.Wm)("li",null,"중복 코드 삭제",-1),b=(0,i.Uk)("이름을 ("),w={href:"https://en.wikipedia.org/wiki/Self-documenting_code",target:"_blank",rel:"noopener noreferrer"},q=(0,i.Uk)("self documenting"),T=(0,i.Uk)(")하게"),_=(0,i.Wm)("li",null,"작은 단위로 메소드 쪼개기",-1),U=(0,i.Wm)("li",null,"상속 위계 재배치",-1),A=(0,i.uE)('<h3 id="_6-반복"><a class="header-anchor" href="#_6-반복">#</a> 6. 반복</h3><ul><li>위의 사이클은 각 기능 단위마다 반복된다.</li><li>테스트들은 small, incremental, 그리고 commits made often 해야한다.</li><li>이러한 방법으로 새로운 코드가 테스트를 실패했을 경우, 과도하게 디버그하기 보다 프로그래머는 단순히 되돌리기나 revert 하면 된다.</li><li>외부 라이브러리를 사용할 경우, 라이브러리 자체만 효과적으로 테스트 할 정도로 작은 테스트를 작성하지 않는 것이 중요하다. <ul><li>라이브러리에 버그가 있거나 개발중인 소프트웨어의 모든 요구 사항을 충족 할만큼 기능이 풍부하지 않다는 이유가없는 한.</li></ul></li></ul><h2 id="개발-스타일"><a class="header-anchor" href="#개발-스타일">#</a> 개발 스타일</h2><blockquote><p>학습 중</p></blockquote><h2 id="모범사례"><a class="header-anchor" href="#모범사례">#</a> 모범사례</h2><h3 id="test-structure"><a class="header-anchor" href="#test-structure">#</a> Test structure</h3><p>테스트 케이스의 레이아웃을 효과적으로 만드는 것은 중요하다. 이는 모든 요구 사항 액션들이 완성되어 있음을 보장한며, 테스트 케이스의 가독성을 향상 시키고, 실행흐름을 매끄럽게 만든다.</p><p>일관성있는 구조는 self-documenting 테스트 케이스를 빌드하는데 도움을 준다. 테스트 케이스들에 일반적으로 적용되는 스트럭쳐는 다음과 같다.</p><ol><li><a href="#setup">setup</a></li><li><a href="#execution">execution</a></li><li><a href="#validation">validation</a></li><li><a href="#cleanup">cleanup</a></li></ol><h4 id="setup"><a class="header-anchor" href="#setup">#</a> setup</h4><ul><li>Unit Under Test (UUT) 또는 전반적인 테스트 시스템을 테스트를 실행하는 데 필요한 상태로 설정.</li></ul><h4 id="execution"><a class="header-anchor" href="#execution">#</a> execution</h4><ul><li>UUT를 트리거 / 드라이브한다. <ul><li>이는 목표한 behavior 를 수행하고, 모든 출력을 capture 하기 위함이다. <ul><li>예를 들면 return values 나, output parameters 같은 출력값</li></ul></li></ul></li><li>이 단계는 주로 아주 간단하다.</li></ul><h4 id="validation"><a class="header-anchor" href="#validation">#</a> validation</h4><ul><li>테스트의 결과가 올바른지 검증한다.</li><li>이 결과들은 UUT 내에서 실행 도중 또는 상태 변화 도중 포착된 명시적인 출력(output)을 포함할 수 있다.</li></ul><h4 id="cleanup"><a class="header-anchor" href="#cleanup">#</a> cleanup</h4><p>UUT나 전반적인 테스트 시스템을 테스트 전 상태로 복구한다. 이 복원은 다른 테스트들을 곧바로 이 테스트 다음에 실행할 수 있게 허용해준다. 몇 케이스들에서는 가능한 테스트 실패 분석에 대한 정보를 유지하기 위해, cleanup 은 테스트 setup 전에 테스트를 시작해야한다.</p><h3 id="개인의-모범-사례"><a class="header-anchor" href="#개인의-모범-사례">#</a> 개인의 모범 사례</h3><p>개인이 따를 수도 있는 몇 가지 모범 사례는 일반적인 set-up 과 tear-down 로직을 적절한 테스트 케이스로부터 사용되는(utilized) 지원 서비스로 분리하고, 각 테스트 oracle<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>이 테스트를 검증하는데 필요한 결과에만 집중하게 하도록 유지하며, 비실시간 운영체제에서의 실행의 관용을 허락하는 시간 관련 테스트(time-realated tests)들을 설계하는 것이다.</p><p>늦은 실행에 대해 5~10% 마진을 허용하는 일반적인 관습은 테스트 실행에서 잠재적인 거짓 음성(false negatives)<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>의 수를 줄여준다. 또 프로덕션 코드와 동일한 관점에서 테스트 코드를 처리하는 것이 좋다. 테스트 코드는 positive 와 negative 케이스 모두에서 올바르게 작동해야 하며, 오래 지속되어야 하고, 가독성과 유지보수성이 좋아야 한다. 팀은 나쁜 습관을 포착하거나 효과적인 기술들을 공유하기 위해 테스트나 테스트 관습을 함께 모으고 검토할 수 있다.</p><h3 id="피해야할-관습-혹은-anti-patterns"><a class="header-anchor" href="#피해야할-관습-혹은-anti-patterns">#</a> 피해야할 관습 혹은 anti-patterns</h3>',21),y={href:"https://en.wikipedia.org/wiki/Anti-pattern",target:"_blank",rel:"noopener noreferrer"},R=(0,i.Uk)("Anti-pattern"),x=(0,i.uE)('<ul><li>이전에 실행된 테스트 케이스로부터 조작 된 시스템 상태에 의존하는 테스트 케이스를 갖는 것. (즉, 항상 known, pre-configured state로부터 유닛테스트를 시작해야한다.)</li><li>테스트 케이스들 사이의 의존성 <ul><li>테스트 케이스가 서로 의존하는 테스트 슈트는 망가지기 쉽고 복잡하다.</li><li>실행 순서를 추정해서는 안된다.</li><li>초기 테스트 케이스 또는 UUT 구조의 기본 리팩토링은 관련 테스트에서 점점 더 많은 영향을 미친다</li></ul></li><li>상호 의존적(interdependent) 테스트. <ul><li>상호 의존적 테스트는 cascading false negatives을 유발할 수 있다.</li><li>초기 테스트 케이스의 실패가 UUT에 실제 결함이없음에도 이후 테스트 케이스를 망가뜨랴, 결함 분석 및 디버그 비용을 증가시킨다.</li></ul></li><li>정확한 실행 behavior 타이밍 또는 퍼포먼스 테스트</li><li>all knowing oracle 을 빌드하는 것. 필요 이상으로 검증하는 오라클은 시간이 지남에 따라 더 비싸고 부서지기 쉽다. <ul><li>이 매우 일반적인 에러는 위험하다. <ul><li>복잡한 프로젝트 전반에 미묘하지만, 만연한 시간감소를 유발하기 때문이다.</li></ul></li></ul></li><li>구현 details 테스트</li><li>느린 실행의 테스트</li></ul><h2 id="이익"><a class="header-anchor" href="#이익">#</a> 이익</h2><blockquote><p>원문 참조</p></blockquote><h2 id="한계"><a class="header-anchor" href="#한계">#</a> 한계</h2><blockquote><p>원문 참조</p></blockquote><h2 id="test-driven-work"><a class="header-anchor" href="#test-driven-work">#</a> Test-driven Work</h2><ul><li>&quot;Add a check&quot; replaces &quot;Add a test&quot;</li><li>&quot;Run all checks&quot; replaces &quot;Run all tests&quot;</li><li>&quot;Do the work&quot; replaces &quot;Write some code&quot;</li><li>&quot;Run all checks&quot; replaces &quot;Run tests&quot;</li><li>&quot;Clean up the work&quot; replaces &quot;Refactor code&quot;</li><li>&quot;Repeat&quot;</li></ul><h2 id="tdd-와-atdd"><a class="header-anchor" href="#tdd-와-atdd">#</a> TDD 와 ATDD</h2>',8),C={href:"https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development",target:"_blank",rel:"noopener noreferrer"},B=(0,i.Uk)("Acceptance test-driven developemnt"),E=(0,i.Wm)("p",null,"TDD 는 ATDD 와 관련이 있다.",-1),S=(0,i.Wm)("p",null,"TDD 는 우선적으로 개발자 툴이며, 이는 잘 쓰여진 코드의 유닛(function, class, module)을 생성하는데 도움을 준다. 이 코드는 연산의 모음들을 올바르게 수행한다.",-1),G=(0,i.Wm)("p",null,"ATDD 는 커뮤니케이션 툴이며, 고객과 개발자, 테스터들 사이의 요구사항이 잘 정의되었는지 보장한다.",-1),K=(0,i.Wm)("p",null,"TDD 는 테스트 자동화를 요구한다.",-1),L=(0,i.Wm)("p",null,"ATDD는 자동화를 요구하진 않지만, 자동화가 regression testing 에 유용하다.",-1),O=(0,i.Wm)("p",null,"코드 유닛이 요구사항의 일부를 구현하기 때문에, TDD 에서 쓰이는 테스트는 자주 ATDD 테스트로부터 파생 될 수 있다.",-1),V=(0,i.Wm)("p",null,"ATDD 테스트는 고객이 읽기 쉬워야하지만, TDD는 그럴 필요가 없다.",-1),F=(0,i.Wm)("h2",{id:"tdd-and-bdd"},[(0,i.Wm)("a",{class:"header-anchor",href:"#tdd-and-bdd"},"#"),(0,i.Uk)(" TDD and BDD")],-1),I={href:"https://en.wikipedia.org/wiki/Behavior-driven_development",target:"_blank",rel:"noopener noreferrer"},P=(0,i.Uk)("behavior-driven development"),Y=(0,i.uE)('<p>BDD는 TDD와 ATDD 관습의 결합이다. 먼저 테스트를 작성하는 관습을 포함하지만, 구현 유닛을 테스트하는 것보다는 behavior를 설명하는 것에 집중한다. JBehave 나 Cucumber, Mspec, 그리고 Specflow 같은 툴은 프로덕트 오너, 개발자들, 그리고 테스트 엔지너들이 함께 자동 테스트로 전환할 수 있는 behavior를 정의하는 것을 허용하는 구문들을 제공한다.</p><h2 id="code-visibility"><a class="header-anchor" href="#code-visibility">#</a> Code Visibility</h2><blockquote><p>원문 참조</p></blockquote><h2 id="관련-소프트웨어"><a class="header-anchor" href="#관련-소프트웨어">#</a> 관련 소프트웨어</h2><blockquote><p>원문 참조</p></blockquote><h2 id="fakes-mocks-and-integration-tests"><a class="header-anchor" href="#fakes-mocks-and-integration-tests">#</a> Fakes, mocks and integration tests</h2><blockquote><p>원문 참조</p></blockquote><h2 id="복잡한-시스템을-위한-tdd"><a class="header-anchor" href="#복잡한-시스템을-위한-tdd">#</a> 복잡한 시스템을 위한 TDD</h2><blockquote><p>원문 참조</p></blockquote><hr class="footnotes-sep">',10),j={class:"footnotes"},z={class:"footnotes-list"},H=(0,i.Wm)("li",{id:"fn1",class:"footnote-item"},[(0,i.Wm)("p",null,[(0,i.Uk)("Beck, Kent (2002-11-08). Test-Driven Development by Example. Vaseem: Addison Wesley. ISBN 978-0-321-14653-3. "),(0,i.Wm)("a",{href:"#fnref1",class:"footnote-backref"},"↩︎")])],-1),J=(0,i.Wm)("li",{id:"fn2",class:"footnote-item"},[(0,i.Wm)("p",null,[(0,i.Uk)("테스트 하네스. 테스트를 진행하기 위한 환경의 일부분으로, 단위 시험이나 모듈 시험에 사용하기 위해 만든 상위의 임시 모듈 "),(0,i.Wm)("a",{href:"#fnref2",class:"footnote-backref"},"↩︎")])],-1),M={id:"fn3",class:"footnote-item"},N={href:"https://en.wikipedia.org/wiki/Test_oracle",target:"_blank",rel:"noopener noreferrer"},Q=(0,i.Uk)("테스트 오라클"),X=(0,i.Uk)(". 테스트가 통과되었는지 실패하였는지 결정하는 메커니즘. "),Z=(0,i.Wm)("a",{href:"#fnref3",class:"footnote-backref"},"↩︎",-1),$=(0,i.Wm)("li",{id:"fn4",class:"footnote-item"},[(0,i.Wm)("p",null,[(0,i.Uk)("통계상 실제로는 양성인데 검사 결과는 음성이라고 나오는 것. 예) 스팸메일인데 아니라고 분류하는 것 "),(0,i.Wm)("a",{href:"#fnref4",class:"footnote-backref"},"↩︎")])],-1),ee={render:function(e,l){const t=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.j4)(i.HY,null,[a,(0,i.Wm)("blockquote",null,[(0,i.Wm)("p",null,[(0,i.Wm)("a",s,[r,(0,i.Wm)(t)])]),n]),o,d,u,(0,i.Wm)("blockquote",null,[(0,i.Wm)("p",null,[(0,i.Wm)("a",h,[c,(0,i.Wm)(t)]),p])]),f,(0,i.Wm)("ul",null,[m,k,v,(0,i.Wm)("li",null,[W,(0,i.Wm)("ul",null,[g,D,(0,i.Wm)("li",null,[b,(0,i.Wm)("a",w,[q,(0,i.Wm)(t)]),T]),_,U])])]),A,(0,i.Wm)("blockquote",null,[(0,i.Wm)("p",null,[(0,i.Wm)("em",null,[(0,i.Wm)("a",y,[R,(0,i.Wm)(t)])])])]),x,(0,i.Wm)("blockquote",null,[(0,i.Wm)("p",null,[(0,i.Wm)("a",C,[B,(0,i.Wm)(t)])])]),E,S,G,K,L,O,V,F,(0,i.Wm)("blockquote",null,[(0,i.Wm)("p",null,[(0,i.Wm)("a",I,[P,(0,i.Wm)(t)])])]),Y,(0,i.Wm)("section",j,[(0,i.Wm)("ol",z,[H,J,(0,i.Wm)("li",M,[(0,i.Wm)("p",null,[(0,i.Wm)("a",N,[Q,(0,i.Wm)(t)]),X,Z])]),$])])],64)}}},1225:(e,l,t)=>{"use strict";t.r(l),t.d(l,{data:()=>i});const i={key:"v-45794417",path:"/sw/tdd.html",title:"Test Driven Development",lang:"ko-KR",frontmatter:{sidebar:"auto"},excerpt:"",headers:[{level:2,title:"Overview",slug:"overview",children:[]},{level:2,title:"Cycle",slug:"cycle",children:[{level:3,title:"1. 테스트 추가(Add a test)",slug:"_1-테스트-추가-add-a-test",children:[]},{level:3,title:"2. 모든 테스트 실행(Run all tests)",slug:"_2-모든-테스트-실행-run-all-tests",children:[]},{level:3,title:"3. 테스트를 통과하는 가장 간단한 코드 작성(Write the simplest code that passes the new test)",slug:"_3-테스트를-통과하는-가장-간단한-코드-작성-write-the-simplest-code-that-passes-the-new-test",children:[]},{level:3,title:"4. 모든 테스트 통과(All tests should now pass)",slug:"_4-모든-테스트-통과-all-tests-should-now-pass",children:[]},{level:3,title:"5. 리팩토링(Refactor as needed)",slug:"_5-리팩토링-refactor-as-needed",children:[]},{level:3,title:"6. 반복",slug:"_6-반복",children:[]}]},{level:2,title:"개발 스타일",slug:"개발-스타일",children:[]},{level:2,title:"모범사례",slug:"모범사례",children:[{level:3,title:"Test structure",slug:"test-structure",children:[]},{level:3,title:"개인의 모범 사례",slug:"개인의-모범-사례",children:[]},{level:3,title:"피해야할 관습 혹은 anti-patterns",slug:"피해야할-관습-혹은-anti-patterns",children:[]}]},{level:2,title:"이익",slug:"이익",children:[]},{level:2,title:"한계",slug:"한계",children:[]},{level:2,title:"Test-driven Work",slug:"test-driven-work",children:[]},{level:2,title:"TDD 와 ATDD",slug:"tdd-와-atdd",children:[]},{level:2,title:"TDD and BDD",slug:"tdd-and-bdd",children:[]},{level:2,title:"Code Visibility",slug:"code-visibility",children:[]},{level:2,title:"관련 소프트웨어",slug:"관련-소프트웨어",children:[]},{level:2,title:"Fakes, mocks and integration tests",slug:"fakes-mocks-and-integration-tests",children:[]},{level:2,title:"복잡한 시스템을 위한 TDD",slug:"복잡한-시스템을-위한-tdd",children:[]}],filePathRelative:"sw/tdd.md",git:{updatedTime:1619519668e3}}}}]);